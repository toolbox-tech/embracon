name: Deploy Kafka Processor Confluent v1

on:
  workflow_call:
    inputs:
      # Variaveis que os projetos podem sobrescrever
      environment:
        description: 'Ambiente de execução do build'
        required: true
        type: string
      project:
        description: 'Nome do projeto'
        required: true
        type: string
      dockerFile:
        description: 'Imagem docker corporativa'
        required: false
        type: string
      buildArgs:
        description: 'Argumentos que serão repassados no momento do build da imagem'
        required: false
        type: string

      # Variaveis que permitem sobrescrever via formulário
      skipBuild:
        description: 'Se sim, todo o processo de build será saltado.'
        default: false
        required: false
        type: boolean

env:
  REGISTRY: sa-saopaulo-1.ocir.io/grxpv7i9yybu
  VERSION: ${{ github.run_id }}.${{ github.run_number }}.${{ github.run_attempt }}

jobs:
         
  Build:
     name: Build
     runs-on: ubuntu-24.04
     steps:

        - name: Checkout
          uses: actions/checkout@v4

        - name: Generate GitHub App JWT Token
          id: generate_jwt
          env:
            APP_ID: "1039452"  
            PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
          run: |
            # Instalação do openssl e dependências
            # sudo apt-get update && sudo apt-get install -y jq openssl
  
            # Gerando o token JWT
            header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            unsigned_token="$header.$payload"
            signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            jwt="$unsigned_token.$signature"
  
            echo "JWT=$jwt" >> $GITHUB_OUTPUT

        - name: Get Installation Access Token
          id: get_install_token
          env:
            JWT: "${{ steps.generate_jwt.outputs.JWT }}"
          run: |
            response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
            token=$(echo "$response" | jq -r '.token')
            echo "INSTALLATION_TOKEN=$token" >> "$GITHUB_OUTPUT"
        
        - name: Clone Template Repository
          run: |
            git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo       

        - name: Login to Oracle Container Registry
          run: echo "${{ secrets.OCI_PASSWORD }}" | docker login ${{ env.REGISTRY }} --username ${{ secrets.OCI_USERNAME }} --password-stdin    
        
        - name: Set Build Image
          run: |
            if [[ "${{ inputs.environment }}" == "prod" || "${{ inputs.environment }}" == "hom" ]]; then
              dockerfilePath=${{ inputs.dockerFile }}
              if [[ -z "${{ inputs.dockerFile }}" ]]; then
                echo "Erro: Para o ambiente '${{ inputs.environment }}', é obrigatório especificar o Dockerfile corporativo."
                exit 1
              fi
              cp template_repo/dockerfiles/${dockerfilePath}/Dockerfile .
            fi

            if [[ "${{ inputs.environment }}" == "dev" ]]; then
              dockerfilePath=${{ inputs.dockerFile }}
              if [[ -n "${{ inputs.dockerFile }}" ]]; then
                 cp template_repo/dockerfiles/${dockerfilePath}/Dockerfile .
              fi
            fi
            
        - name: Build Image
          shell: pwsh
          run: | 
            .\build.ps1 -registry "${{ env.REGISTRY }}" -project "${{ inputs.project }}" -buildVersion "${{ env.VERSION }}" -environment "${{ inputs.environment }}"  
            docker tag ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:${{ env.VERSION }} ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:latest
  
        - name: Push Docker image with version tag
          run: docker push ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:${{ env.VERSION }}
  
        - name: Push Docker image with latest tag
          run: docker push ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:latest


  Deploy:
    name: Deploy
    runs-on: self-hosted
    needs: Build
    steps:
        # - run: |
        #     echo  ${{ env.SECRETS_DEPLOY }}
        #     echo  ${{ env.SECRETS_DEPLOY == 'true' }}
        #     echo  ${{ env.SECRETS_DEPLOY == true }}

        - name: Checkout
          uses: actions/checkout@v4

        - name: Generate GitHub App JWT Token
          id: generate_jwt
          env:
            APP_ID: "1039452"  
            PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
          run: |
            # Instalação do openssl e dependências
            # sudo apt-get update && sudo apt-get install -y jq openssl
  
            # Gerando o token JWT
            header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            unsigned_token="$header.$payload"
            signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            jwt="$unsigned_token.$signature"
  
            echo "JWT=$jwt" >> $GITHUB_ENV

        - name: Get Installation Access Token
          id: get_install_token
          env:
            JWT: "${{ env.JWT }}"
          run: |
            response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
            token=$(echo "$response" | jq -r '.token')
            echo "INSTALLATION_TOKEN=$token" >> "$GITHUB_OUTPUT"
        
        - name: Clone Template Repository
          run: |
            git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo


        - name: Load Variables
          id: load-variables
          run: |

            echo "OKE_DEV_HOM_CLUSTER_HOST=$(yq '.OKE_DEV_HOM_CLUSTER_HOST' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "OKE_PROD_KAFKA_CLUSTER_HOST=$(yq '.OKE_PROD_KAFKA_CLUSTER_HOST' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"


        - name: Configure Cluster NonProd
          if: ${{ inputs.environment == 'dev' || inputs.environment == 'hom'}}
          run: |
            kubectl config set-cluster context-csdszlbgqyt --server=${{ steps.load-variables.outputs.OKE_DEV_HOM_CLUSTER_HOST }} --insecure-skip-tls-verify=true
            kubectl config set-credentials oke-admin --token=${{ secrets.OCI_OKE_TOKEN_DEV_HOM }}
            kubectl config set-context context-csdszlbgqyt --cluster=context-csdszlbgqyt --user=jenkins-sa
            kubectl config use-context context-csdszlbgqyt
            kubectl config set-context --current --user=oke-admin

        - name: Configure Cluster Prod
          if: ${{ inputs.environment == 'prod'}}
          run: |
            kubectl config set-cluster context-csdszlbgqyt --server=${{ steps.load-variables.outputs.OKE_PROD_KAFKA_CLUSTER_HOST }} --insecure-skip-tls-verify=true
            kubectl config set-credentials oke-admin --token=${{ secrets.OCI_OKE_KAFKA_TOKEN_PROD }}
            kubectl config set-context context-csdszlbgqyt --cluster=context-csdszlbgqyt --user=jenkins-sa
            kubectl config use-context context-csdszlbgqyt
            kubectl config set-context --current --user=oke-admin
            
        - name: Login to Oracle Container Registry
          run: echo "${{ secrets.OCI_PASSWORD }}" | docker login ${{ env.REGISTRY }} --username ${{ secrets.OCI_USERNAME }} --password-stdin    
  
        - name: Download Image
          run: | 
            docker pull ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:${{ env.VERSION }}
            docker tag ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:${{ env.VERSION }} embracon/${{ inputs.environment }}/ksqldb:1.0.0

        - name: Deploy Packages
          shell: pwsh
          run: |
            .\deploy.ps1 -version "${{ env.VERSION }}" -buildVersion "${{ env.VERSION }}" -isDeploy "true"  -environment "${{ inputs.environment }}" -registry "${{ env.REGISTRY }}" -project "${{ inputs.project }}"

        - name: Cleanup
          if: always()
          continue-on-error: true
          run: |
            docker rmi ${{ env.REGISTRY }}/${{ inputs.environment }}/${{ inputs.project }}:${{ env.VERSION }} -f || true
            docker rmi embracon/${{ inputs.environment }}/ksqldb:1.0.0 -f || true
            for id in $(docker ps -aq); do docker stop $id; docker rm $id; done



