name: Deploy Redis Job v1

on:
  workflow_call:
    inputs:
      # Variaveis que os projetos podem sobrescrever
      environment:
        description: 'Ambiente de execução do build'
        required: true
        type: string
      project:
        description: 'Nome do projeto'
        required: true
        type: string
      dockerFile:
        description: 'Imagem docker corporativa'
        required: false
        type: string
      buildArgs:
        description: 'Argumentos que serão repassados no momento do build da imagem'
        default: ''
        required: false
        type: string
      cron:
        description: 'Cron para intervalo de passagem. Se não for especificado será utilizado o padrão: 0 1 * * * (Todos os dias à 01h da manhã).'
        required: false
        type: string

      # Variaveis que permitem sobrescrever via formulário
      skipBuild:
        description: 'Se sim, todo o processo de build será saltado.'
        default: false
        required: false
        type: boolean
      skipDeploy:
        description: 'Se sim, todo o processo de deploy será saltado.'
        default: false
        required: false
        type: boolean
      configMapDeploy:
        description: 'Se sim, vai fazer o apply do ConfigMap. Atenção: estão função sobrescreve os valores atuais.'
        default: false
        required: false
        type: boolean
      secretsDeploy:
        description: 'Se sim, vai fazer o apply do Secret. Atenção: estão função sobrescreve os valores atuais.'
        default: false
        required: false
        type: boolean
     
env:
  REGISTRY_OKE: sa-saopaulo-1.ocir.io/grxpv7i9yybu
  REGISTRY_AKS: azrsrvpcrg01.azurecr.io
  VERSION: ${{ github.run_id }}.${{ github.run_number }}.${{ github.run_attempt }}

jobs:

  Input:
    timeout-minutes: 1
    runs-on: ubuntu-24.04
    continue-on-error: true
    outputs:
      REPLICAS: ${{ steps.set-outputs.outputs.REPLICAS }}
      SKIP_BUILD: ${{ steps.set-outputs.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ steps.set-outputs.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ steps.set-outputs.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ steps.set-outputs.outputs.SECRETS_DEPLOY }}
    steps:
      - name: Input Request
        id: interactive-inputs
        uses: boasihq/interactive-inputs@v2
        with:
          ngrok-authtoken: ${{ secrets.NGROK_AUTHTOKEN }}
          title: 'Por favor preencha o formulário para realizar um deploy customizado. Caso contrário, será utilizado os valores padrões.'
          timeout: 60
          interactive: |
            fields:
              - label: skipBuild
                properties:
                  display: Desaja saltar o build?
                  type: boolean
                  description: Se sim, todo o processo de build será saltado.
                  defaultValue: false
                  required: false
              - label: skipDeploy
                properties:
                  display: Deseja saltar o deploy?
                  type: boolean
                  description: Se sim, todo o processo de deploy será saltado.
                  defaultValue: false
                  required: false
              - label: configMapDeploy
                properties:
                  display: Deseja fazer deploy do ConfigMap?
                  type: boolean
                  description: Se sim, o confimap do Kubernetes será sobrescrito para a nova versão.
                  defaultValue: false
                  required: false
              - label: secretsDeploy
                properties:
                  display: Deseja fazer deploy do Secrets?
                  type: boolean
                  description: Se sim, o secrets do Kubernetes será sobrescrito para a nova versão.
                  defaultValue: false
                  required: false

      - name: Display Inputs
        shell: bash
        run: |

          echo "Display Inputs"
          echo -e "\n==============================\n"
          echo "Detected Inputs: ${{join(steps.interactive-inputs.outputs.*, '\n')}}"
          echo -e "\n==============================\n"
        
      - name: Set Outputs
        id: set-outputs
        run: |

          echo "SKIP_BUILD=${{ steps.interactive-inputs.outputs.skipBuild }}" >> "$GITHUB_OUTPUT"
          echo "SKIP_DEPLOY=${{ steps.interactive-inputs.outputs.skipDeploy }}" >> "$GITHUB_OUTPUT"
          echo "CONFIGMAP_DEPLOY=${{ steps.interactive-inputs.outputs.configMapDeploy }}" >> "$GITHUB_OUTPUT"
          echo "SECRETS_DEPLOY=${{ steps.interactive-inputs.outputs.secretsDeploy }}" >> "$GITHUB_OUTPUT"

  Variables:
    runs-on: ubuntu-24.04
    needs: Input
    outputs:
      SKIP_BUILD: ${{ steps.set-variables.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ steps.set-variables.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ steps.set-variables.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ steps.set-variables.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ steps.set-variables.outputs.PROJECT }}
      DOCKERFILE: ${{ steps.set-variables.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ steps.set-variables.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ steps.set-variables.outputs.BUILD_ARGS }}
    env:
      SKIP_BUILD: ${{ needs.Input.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Input.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Input.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Input.outputs.SECRETS_DEPLOY }}
    steps:  
      - name: Set Variables
        id: set-variables
        run: |


          echo "SKIP_BUILD=${{ env.SKIP_BUILD }}" >> "$GITHUB_OUTPUT"
          if [[ "${{ env.SKIP_BUILD }}" == "" ]]; then
            echo "SKIP_BUILD=${{ inputs.skipBuild  }}" >> "$GITHUB_OUTPUT"
          fi

          echo "SKIP_DEPLOY=${{ env.SKIP_DEPLOY }}" >> "$GITHUB_OUTPUT"
          if [[ "${{ env.SKIP_DEPLOY }}" == "" ]]; then
            echo "SKIP_DEPLOY=${{ inputs.skipDeploy  }}" >> "$GITHUB_OUTPUT"
          fi

          echo "CONFIGMAP_DEPLOY=${{ env.CONFIGMAP_DEPLOY }}" >> "$GITHUB_OUTPUT"
          if [[ "${{ env.CONFIGMAP_DEPLOY }}" == "" ]]; then
            echo "CONFIGMAP_DEPLOY=${{ inputs.configMapDeploy  }}" >> "$GITHUB_OUTPUT"
          fi

          echo "SECRETS_DEPLOY=${{ env.SECRETS_DEPLOY }}" >> "$GITHUB_OUTPUT"
          if [[ "${{ env.SECRETS_DEPLOY }}" == "" ]]; then
            echo "SECRETS_DEPLOY=${{ inputs.secretsDeploy  }}" >> "$GITHUB_OUTPUT"
          fi

          echo "PROJECT=${{ inputs.project }}" >> "$GITHUB_OUTPUT"
          echo "DOCKERFILE=${{ inputs.dockerFile }}" >> "$GITHUB_OUTPUT"
          echo "PROJECT_ENV=${{ inputs.environment }}" >> "$GITHUB_OUTPUT"
          echo "BUILD_ARGS=${{ inputs.buildArgs }}" >> "$GITHUB_OUTPUT"

  Build_OKE:
    name: Build_OKE
    runs-on: ubuntu-24.04
    needs: Variables
    outputs:
      SKIP_BUILD: ${{ needs.Variables.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Variables.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Variables.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Variables.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Variables.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Variables.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Variables.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Variables.outputs.BUILD_ARGS }}
    env:
      SKIP_BUILD: ${{ needs.Variables.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Variables.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Variables.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Variables.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Variables.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Variables.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Variables.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Variables.outputs.BUILD_ARGS }}
    steps:
      - name: Generate GitHub App JWT Token
        id: generate_jwt
        env:
          APP_ID: "1039452"  
          PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
        run: |
         
          header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          unsigned_token="$header.$payload"
          signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          jwt="$unsigned_token.$signature"

          echo "JWT=$jwt" >> $GITHUB_ENV

      - name: Get Installation Access Token
        id: get_install_token
        env:
          JWT: "${{ env.JWT }}"
        run: |
          response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
          token=$(echo "$response" | jq -r '.token')
          echo "INSTALLATION_TOKEN=$token" >> "$GITHUB_OUTPUT"
      
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          token: ${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}
          submodules: true
          fetch-depth: 0
          
     
      - name: Force Load environment variables
        run: |
          echo "Loading environment variables from .env file"
          source $GITHUB_ENV
        

      - name: Include Submodules
        run: |
          git submodule init

      - name: Clone Template Repository        
        run: |
          git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo
       
      - name: Login OCI Container Registry
        run: echo "${{ secrets.OCI_PASSWORD }}" | docker login ${{ env.REGISTRY_OKE }} --username ${{ secrets.OCI_USERNAME }} --password-stdin    
        
      - name: Build OKE Image
        if: ${{ env.SKIP_BUILD == 'false' }}
        run: |
         if [[ "${{ env.PROJECT_ENV }}" == "prod" || "${{ env.PROJECT_ENV }}" == "hom" ]]; then
            dockerfilePath=${{ env.DOCKERFILE }}
         if [[ -z "${{ env.DOCKERFILE }}" ]]; then
              echo "Erro: Para o ambiente '${{ env.PROJECT_ENV }}', é obrigatório especificar o Dockerfile corporativo."
              exit 1
         fi
         elif [[ "${{ env.PROJECT_ENV }}" == "dev" ]]; then
           
            dockerfilePath=${{ env.DOCKERFILE }}
         else
           
            echo "Ambiente não especificado. Usando Dockerfile padrão no caminho 'Dockerfile'."
            
         fi
          
          buildCmd="docker build -t ${{ env.REGISTRY_OKE }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }} --build-arg ENVIRONMENT=${{ env.PROJECT_ENV }} --build-arg TNSADMIN=/usr/lib/oracle/18.3/client64/lib/network/admin"

          if [ -n "${{ env.BUILD_ARGS }}" ]; then
            echo "BuildArgs definidos. Adicionando ao comando de build."
            buildCmd+=" --build-arg BUILD_ARGS=\"${{ env.BUILD_ARGS }}\""
          else
            echo "buildArgs não definidos. Executando build sem buildArgs adicionais."
          fi
          
          # Completar o comando com o caminho do Dockerfile e executar
          if [[ -n "${{ env.DOCKERFILE }}" ]]; then
            buildCmd+=" -f template_repo/dockerfiles/${dockerfilePath}/Dockerfile ."
          else
            buildCmd+=" -f Dockerfile ."
          fi
          echo "Executando comando: $buildCmd"
          eval "$buildCmd"
          
          # Tag para 'latest'
          docker tag ${{ env.REGISTRY_OKE }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }} ${{ env.REGISTRY_OKE }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:latest
   
      - name: Push OKE Docker Image
        if: ${{ env.SKIP_BUILD == 'false' }}
        run: | 
          docker push ${{ env.REGISTRY_OKE }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }}
          docker push ${{ env.REGISTRY_OKE }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:latest

  Deploy_OKE:
     name: Deploy_OKE
     runs-on: self-hosted
     needs: Build_OKE
     outputs:
      SKIP_BUILD: ${{ needs.Build_OKE.outputs.SKIP_BUILD }}
      CONFIGMAP_DEPLOY: ${{ needs.Build_OKE.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Build_OKE.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Build_OKE.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Build_OKE.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Build_OKE.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Build_OKE.outputs.BUILD_ARGS }}
     env: 
      SKIP_BUILD: ${{ needs.Build_OKE.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Build_OKE.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Build_OKE.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Build_OKE.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Build_OKE.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Build_OKE.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Build_OKE.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Build_OKE.outputs.BUILD_ARGS }}
     steps:
        # - run: |
        #     echo  ${{ env.SECRETS_DEPLOY }}
        #     echo  ${{ env.SECRETS_DEPLOY == 'true' }}
        #     echo  ${{ env.SECRETS_DEPLOY == true }}

        - name: Checkout
          uses: actions/checkout@v4

        - name: Generate GitHub App JWT Token
          id: generate_jwt
          env:
            APP_ID: "1039452"  
            PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
          run: |
            # Instalação do openssl e dependências
            # sudo apt-get update && sudo apt-get install -y jq openssl
  
            # Gerando o token JWT
            header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            unsigned_token="$header.$payload"
            signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            jwt="$unsigned_token.$signature"
  
            echo "JWT=$jwt" >> $GITHUB_ENV

        - name: Get Installation Access Token
          id: get_install_token
          env:
            JWT: "${{ env.JWT }}"
          run: |
            response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
            token=$(echo "$response" | jq -r '.token')
            echo "INSTALLATION_TOKEN=$token" >> "$GITHUB_OUTPUT"
        
        - name: Clone Template Repository
          run: |
            git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo


        - name: Load OKE Variables
          id: load-oke-variables
          run: |

            echo "HEALTH_CHECK_ENDPOINT_PROD=$(yq '.HEALTH_CHECK_ENDPOINT_PROD' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "HEALTH_CHECK_ENDPOINT_HOM=$(yq '.HEALTH_CHECK_ENDPOINT_HOM' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "HEALTH_CHECK_ENDPOINT_DES=$(yq '.HEALTH_CHECK_ENDPOINT_DES' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "OKE_DEV_HOM_CLUSTER_HOST=$(yq '.OKE_DEV_HOM_CLUSTER_HOST' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "OKE_PROD_CLUSTER_HOST=$(yq '.OKE_PROD_CLUSTER_HOST' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
            echo "OKE_PROD_KAFKA_CLUSTER_HOST=$(yq '.OKE_PROD_KAFKA_CLUSTER_HOST' template_repo/vars.yml)" >> "$GITHUB_OUTPUT"
              
        - name: Seds OKE Apllication And Envs
          run: |
            sed -i 's/#APPLICATION_NAME#/${{ env.PROJECT }}/g' oci/kubernetes.yml
            sed -i 's/#APPLICATION_IMAGE_NAME#/${{ env.PROJECT }}/g' oci/kubernetes.yml
            sed -i 's/#ENV#/${{ env.PROJECT_ENV }}/g' oci/kubernetes.yml
            sed -i 's/#APP_VERSION#/${{ env.VERSION }}/g' oci/kubernetes.yml
            sed -i 's|#REGISTRY#|${{ env.REGISTRY_OKE }}|g' oci/kubernetes.yml
            sed -i 's|#CRON_TIME#|${{ inputs.cron }}|g' oci/kubernetes.yml
            cat oci/kubernetes.yml
              
        - name: Seds OKE EndpointHealthCheck - prod
          if: ${{ env.PROJECT_ENV == 'prod' }}
          run: |
            sed -i 's|#HEALTH_CHECK_ENDPOINT#|${{ steps.load-oke-variables.outputs.HEALTH_CHECK_ENDPOINT_PROD }}|g' oci/kubernetes.yml

        - name: Seds OKE EndpointHealthCheck - homolog
          if: ${{ env.PROJECT_ENV == 'hom' }}
          run: |
            sed -i 's|#HEALTH_CHECK_ENDPOINT#|${{ steps.load-oke-variables.outputs.HEALTH_CHECK_ENDPOINT_HOM }}|g' oci/kubernetes.yml

        - name: Seds OKE EndpointHealthCheck - develop
          if: ${{ env.PROJECT_ENV == 'dev' }}
          run: |
            sed -i 's|#HEALTH_CHECK_ENDPOINT#|${{ steps.load-oke-variables.outputs.HEALTH_CHECK_ENDPOINT_DES }}|g' oci/kubernetes.yml
              
        - name: Apply Config Map
          if: ${{ env.CONFIGMAP_DEPLOY == 'true' }}
          run: | 
            kubectl apply -f oci/configmap-service.yml
            
        - name: Apply Secrets
          if: ${{ env.SECRETS_DEPLOY == 'true' }}
          run: |
            kubectl apply -f oci/secrets-service.yml

        - name: Apply in Cluster OKE-PROD
          if: env.SKIP_DEPLOY == 'false' && env.PROJECT_ENV == 'prod' 
          run: |
            > $HOME/.kube/config
            kubectl config set-cluster context-csdszlbgqyt --server=${{ steps.load-oke-variables.outputs.OKE_PROD_CLUSTER_HOST }} --insecure-skip-tls-verify=true
            kubectl config set-credentials oke-admin --token=${{ secrets.OCI_OKE_TOKEN_PROD }}
            kubectl config set-context context-csdszlbgqyt --cluster=context-csdszlbgqyt --user=jenkins-sa
            kubectl config use-context context-csdszlbgqyt
            kubectl config set-context --current --user=oke-admin
            kubectl get namespaces
            cat oci/kubernetes.yml
            kubectl apply -f oci/kubernetes.yml
            
        - name: Apply in Cluster OKE-DEV-HOM 
          if: env.SKIP_DEPLOY == 'false' && (env.PROJECT_ENV == 'dev' || env.PROJECT_ENV == 'hom')
          run: |
            > $HOME/.kube/config
            echo ${{ steps.load-oke-variables.outputs.OKE_DEV_HOM_CLUSTER_HOST }} 
            kubectl config set-cluster context-csdszlbgqyt --server=${{ steps.load-oke-variables.outputs.OKE_DEV_HOM_CLUSTER_HOST }} --insecure-skip-tls-verify=true
            kubectl config set-context --cluster=context-csdszlbgqyt context-csdszlbgqyt
            kubectl config set-credentials oke-admin --token=${{ secrets.OCI_OKE_TOKEN_DEV_HOM }} --context=context-csdszlbgqyt
            kubectl config use-context context-csdszlbgqyt
            kubectl config set-context --current --user=oke-admin
            kubectl get namespaces
            cat oci/kubernetes.yml
            kubectl apply -f oci/kubernetes.yml

  Build_AKS:
    name: Build_AKS
    runs-on: ubuntu-24.04
    needs: Variables
    outputs:
      SKIP_BUILD: ${{ needs.Variables.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Variables.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Variables.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Variables.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Variables.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Variables.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Variables.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Variables.outputs.BUILD_ARGS }}
    env:
      SKIP_BUILD: ${{ needs.Variables.outputs.SKIP_BUILD }}
      SKIP_DEPLOY: ${{ needs.Variables.outputs.SKIP_DEPLOY }}
      CONFIGMAP_DEPLOY: ${{ needs.Variables.outputs.CONFIGMAP_DEPLOY }}
      SECRETS_DEPLOY: ${{ needs.Variables.outputs.SECRETS_DEPLOY }}
      PROJECT: ${{ needs.Variables.outputs.PROJECT }}
      DOCKERFILE: ${{ needs.Variables.outputs.DOCKERFILE }}
      PROJECT_ENV:  ${{ needs.Variables.outputs.PROJECT_ENV }}
      BUILD_ARGS:  ${{ needs.Variables.outputs.BUILD_ARGS }}
    steps:
      - name: Generate GitHub App JWT Token
        id: generate_jwt
        env:
          APP_ID: "1039452"  
          PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
        run: |
          
          header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          unsigned_token="$header.$payload"
          signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
          jwt="$unsigned_token.$signature"

          echo "JWT=$jwt" >> $GITHUB_ENV
      
      - name: Get Installation Access Token
        id: get_install_token
        env:
          JWT: "${{ env.JWT }}"
        run: |
          response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
          token=$(echo "$response" | jq -r '.token')
          echo "INSTALLATION_TOKEN=$token" >> $GITHUB_OUTPUT
      
      - name: Checkout code with submodules
        uses: actions/checkout@v3
        with:
          token: ${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}
          submodules: true
          fetch-depth: 0
  
      - name: Force Load environment variables
        run: |
          echo "Loading environment variables from .env file"
          source $GITHUB_ENV
        

      - name: Include Submodules
        run: |
          git submodule init


      - name: Clone Template Repository
              
        run: |
          git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo
        
          
      - name: Load AKS Variables
        run: |
          
          echo "AD_NAMESERVER_DEV=$(yq '.AD_NAMESERVER_DEV' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_NAMESERVER_HOM=$(yq '.AD_NAMESERVER_HOM' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_NAMESERVER_PROD_01=$(yq '.AD_NAMESERVER_PROD_01' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_NAMESERVER_PROD_02=$(yq '.AD_NAMESERVER_PROD_02' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_NAMESERVER=$(yq '.AD_NAMESERVER' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_SEARCH_DEV_HOM=$(yq '.AD_SEARCH_DEV_HOM' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AD_SEARCH_PROD=$(yq '.AD_SEARCH_PROD' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AKS_PROD_CLUSTER_HOST=$(yq '.AKS_PROD_CLUSTER_HOST' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AKS_DEV_HOM_CLUSTER_HOST=$(yq '.AKS_DEV_HOM_CLUSTER_HOST' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AKS_RESOURCE_PROD=$(yq '.AKS_RESOURCE_PROD' template_repo/vars.yml)" >> $GITHUB_ENV
          echo "AKS_RESOURCE_DEV_HOM=$(yq '.AKS_RESOURCE_DEV_HOM' template_repo/vars.yml)" >> $GITHUB_ENV
          
      - name: Build AKS Image
        if: ${{ env.SKIP_BUILD == 'false' }}
        run: |
          
          if [[ "${{ env.PROJECT_ENV }}" == "prod" || "${{ env.PROJECT_ENV }}" == "hom" ]]; then
            dockerfilePath=${{ env.DOCKERFILE }}
            if [[ -z "${{ env.DOCKERFILE }}" ]]; then
              echo "Erro: Para o ambiente '${{ env.PROJECT_ENV }}', é obrigatório especificar o Dockerfile corporativo."
              exit 1
            fi
          elif [[ "${{env.PROJECT_ENV }}" == "dev" ]]; then
            
            dockerfilePath=${{ env.DOCKERFILE }}
          else
            
            echo "Ambiente não especificado. Usando Dockerfile padrão no caminho 'Dockerfile'."
            
          fi
          
          buildCmd="docker build -t ${{ env.REGISTRY_AKS }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }} --build-arg ENVIRONMENT=${{ env.PROJECT_ENV }}"

          if [ -n "${{ env.BUILD_ARGS }}" ]; then
            echo "BuildArgs definidos. Adicionando ao comando de build."
            buildCmd+=" --build-arg BUILD_ARGS=\"${{ env.BUILD_ARGS }}\""
          else
            echo "buildArgs não definidos. Executando build sem buildArgs adicionais."
          fi
          
          # Verificar se dockerArgs estão definidos e adicioná-los ao comando
          if [ -n "${{ env.DOCKERFILE }}" ]; then
            echo "DockerArgs definidos. Adicionando ao comando de build."
            IFS=',' read -ra argsArray <<< "${{ env.DOCKERFILE }}"
            for arg in "${argsArray[@]}"; do
              buildCmd+=" --build-arg $arg"
            done
          else
            echo "dockerArgs não definidos. Executando build sem dockerArgs adicionais."
          fi
          
          # Completar o comando com o caminho do Dockerfile e executar
          if [[ -n "${{ env.DOCKERFILE }}" ]]; then
            buildCmd+=" -f template_repo/dockerfiles/${dockerfilePath}/Dockerfile ."
          else
            buildCmd+=" -f Dockerfile ."
          fi
          echo "Executando comando: $buildCmd"
          eval "$buildCmd"
          
          # Tag para 'latest'
          docker tag ${{ env.REGISTRY_AKS }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }} ${{ env.REGISTRY_AKS }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:latest

      - name: Login Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: azrsrvpcrg01.azurecr.io
          username: ${{ secrets.ACR_ENTRA_CLIENT_ID }}
          password: ${{ secrets.ACR_ENTRA_SECRET }}
      
      - name: Push AKS Docker Image
        if: ${{ env.SKIP_BUILD == 'false' }}
        run: |
          
          docker push ${{ env.REGISTRY_AKS }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:${{ env.VERSION }}
          docker push ${{ env.REGISTRY_AKS }}/${{ env.PROJECT_ENV }}/${{ env.PROJECT }}:latest
  
  Deploy_AKS:
      name: Deploy_AKS
      runs-on: self-hosted
      needs: Build_AKS
      outputs:
        SKIP_BUILD: ${{ needs.Build_AKS.outputs.SKIP_BUILD }}
        CONFIGMAP_DEPLOY: ${{ needs.Build_AKS.outputs.CONFIGMAP_DEPLOY }}
        SECRETS_DEPLOY: ${{ needs.Build_AKS.outputs.SECRETS_DEPLOY }}
        PROJECT: ${{ needs.Build_AKS.outputs.PROJECT }}
        DOCKERFILE: ${{ needs.Build_AKS.outputs.DOCKERFILE }}
        PROJECT_ENV:  ${{ needs.Build_AKS.outputs.PROJECT_ENV }}
        BUILD_ARGS:  ${{ needs.Build_AKS.outputs.BUILD_ARGS }}
      env: 
        SKIP_BUILD: ${{ needs.Build_AKS.outputs.SKIP_BUILD }}
        SKIP_DEPLOY: ${{ needs.Build_AKS.outputs.SKIP_DEPLOY }}
        CONFIGMAP_DEPLOY: ${{ needs.Build_AKS.outputs.CONFIGMAP_DEPLOY }}
        SECRETS_DEPLOY: ${{ needs.Build_AKS.outputs.SECRETS_DEPLOY }}
        PROJECT: ${{ needs.Build_AKS.outputs.PROJECT }}
        DOCKERFILE: ${{ needs.Build_AKS.outputs.DOCKERFILE }}
        PROJECT_ENV:  ${{ needs.Build_AKS.outputs.PROJECT_ENV }}
        BUILD_ARGS:  ${{ needs.Build_AKS.outputs.BUILD_ARGS }}
      steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Generate GitHub App JWT Token
          id: generate_jwt
          env:
            APP_ID: "1039452"  
            PRIVATE_KEY: "${{ secrets.ORG_APP_PEM }}"
          run: |
            # Instalação do openssl e dependências
            # sudo apt-get update && sudo apt-get install -y jq openssl
  
            # Gerando o token JWT
            header=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            payload=$(echo -n "{\"iat\":$(date +%s),\"exp\":$(( $(date +%s) + 600 )),\"iss\":$APP_ID}" | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            unsigned_token="$header.$payload"
            signature=$(echo -n "$unsigned_token" | openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY") | openssl base64 -A | tr -d '=' | tr '/+' '_-')
            jwt="$unsigned_token.$signature"
  
            echo "JWT=$jwt" >> $GITHUB_ENV

        - name: Get Installation Access Token
          id: get_install_token
          env:
            JWT: "${{ env.JWT }}"
          run: |
            response=$(curl -s -X POST -H "Authorization: Bearer $JWT" -H "Accept: application/vnd.github.v3+json" https://api.github.com/app/installations/56507526/access_tokens)
            token=$(echo "$response" | jq -r '.token')
            echo "INSTALLATION_TOKEN=$token" >> $GITHUB_OUTPUT

        - name: Clone Template Repository
              
          run: |
            git clone --depth 1 https://x-access-token:${{ steps.get_install_token.outputs.INSTALLATION_TOKEN }}@github.com/embracon-br/pipeline-templates.git template_repo
        
          
        - name: Load Variables
          id: load-aks-variables
          run: |
          
            echo "AD_NAMESERVER_DEV=$(yq '.AD_NAMESERVER_DEV' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_NAMESERVER_HOM=$(yq '.AD_NAMESERVER_HOM' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_NAMESERVER_PROD_01=$(yq '.AD_NAMESERVER_PROD_01' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_NAMESERVER_PROD_02=$(yq '.AD_NAMESERVER_PROD_02' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_NAMESERVER=$(yq '.AD_NAMESERVER' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_SEARCH_DEV_HOM=$(yq '.AD_SEARCH_DEV_HOM' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AD_SEARCH_PROD=$(yq '.AD_SEARCH_PROD' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AKS_PROD_CLUSTER_HOST=$(yq '.AKS_PROD_CLUSTER_HOST' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AKS_DEV_HOM_CLUSTER_HOST=$(yq '.AKS_DEV_HOM_CLUSTER_HOST' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AKS_RESOURCE_PROD=$(yq '.AKS_RESOURCE_PROD' template_repo/vars.yml)" >> $GITHUB_OUTPUT
            echo "AKS_RESOURCE_DEV_HOM=$(yq '.AKS_RESOURCE_DEV_HOM' template_repo/vars.yml)" >> $GITHUB_OUTPUT

        - name: Seds Apllication And Envs
          run: |
            sed -i 's/#APPLICATION_NAME#/${{ env.PROJECT }}/g' k8s/deployment.yml
            sed -i 's/#APPLICATION_IMAGE_NAME#/${{ env.PROJECT }}/g' k8s/deployment.yml
            sed -i 's/#ENV#/${{ env.PROJECT_ENV }}/g' k8s/deployment.yml
            sed -i 's/#APP_VERSION#/${{ env.VERSION }}/g' k8s/deployment.yml
            sed -i 's/#REGISTRY#/${{ env.REGISTRY_AKS }}/g' k8s/deployment.yml
            sed -i 's|#CRON_TIME#|${{ inputs.cron }}|g' k8s/deployment.yml
            sed -i 's/#AKS_NAMESERVER_01#/${{ steps.load-aks-variables.outputs.AD_NAMESERVER_PROD_01 }}/g' k8s/deployment.yml
            sed -i 's/#AKS_NAMESERVER_02#/${{ steps.load-aks-variables.outputs.AD_NAMESERVER_PROD_02 }}/g' k8s/deployment.yml
            sed -i 's/#AKS_NAMESERVER_03#/${{ steps.load-aks-variables.outputs.AD_NAMESERVER_HOM }}/g' k8s/deployment.yml
            cat k8s/deployment.yml
      
        - name: Seds Name Servers and Searchs - prod
          if: ${{ inputs.environment == 'prod' }}
          run: |
            sed -i 's/#AKS_SEARCH#/${{ steps.load-aks-variables.outputs.AD_SEARCH_PROD }}/g' k8s/deployment.yml
            cat k8s/deployment.yml
            
            
        - name: Seds Name Servers and Searchs - non prod
          if: ${{ inputs.environment != 'prod' }}
          run: |
            sed -i 's/#AKS_SEARCH#/${{ steps.load-aks-variables.outputs.AD_SEARCH_DEV_HOM }}/g' k8s/deployment.yml
            cat k8s/deployment.yml

        
        - name: Config cluster
          uses: azure/login@v1
          with:
            creds: ${{ secrets.AZURE_CREDENTIALS }}
        
        - name: Apply Config Map
          if: ${{ env.CONFIGMAP_DEPLOY == 'true' }}
          run: kubectl apply -f k8s/configmap-service.yml

        - name: Apply Secrets
          if: ${{ env.SECRETS_DEPLOY =='true' }}
          run: kubectl apply -f k8s/secrets-service.yml

        - name: Apply in Cluster AKS PROD
          if: env.SKIP_DEPLOY == 'false' && env.PROJECT_ENV == 'prod' 
          run: |
            > $HOME/.kube/config
            az aks get-credentials --resource-group ${{ steps.load-aks-variables.outputs.AKS_RESOURCE_PROD }} --name ${{ steps.load-aks-variables.outputs.AKS_PROD_CLUSTER_HOST }} --overwrite-existing
            kubectl config set-cluster k8s-prod --insecure-skip-tls-verify=true --server=https://${{ steps.load-aks-variables.outputs.AKS_PROD_CLUSTER_HOST }}
            kubectl get namespaces
            kubectl apply -f k8s/deployment.yml
            
        - name: Apply in Cluster AKS-DEV-HOM
          if: env.SKIP_DEPLOY == 'false' && (env.PROJECT_ENV == 'dev' || env.PROJECT_ENV == 'hom')
          run: |
            > $HOME/.kube/config
            az aks get-credentials --resource-group ${{ steps.load-aks-variables.outputs.AKS_RESOURCE_DEV_HOM }} --name ${{ steps.load-aks-variables.outputs.AKS_DEV_HOM_CLUSTER_HOST }} --overwrite-existing
            kubectl config set-cluster k8s-dev-hom --insecure-skip-tls-verify=true --server=https://${{ steps.load-aks-variables.outputs.AKS_DEV_HOM_CLUSTER_HOST }}
            kubectl get namespaces
            cat k8s/deployment.yml
            kubectl apply -f k8s/deployment.yml


  # # Veracode:
  # #   name: Veracode
  # #   uses: embracon-br/pipeline-templates/.github/workflows/veracode-template-v2.yml@main
  # #   secrets: inherit
  # #   with:
  # #     build-id: ${{ github.run_id }}
  # #     environment: ${{ inputs.environment }}
  # #     project_veracode: ${{ inputs.project }}